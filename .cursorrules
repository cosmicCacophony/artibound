# Artibound - Game Development Project Rules

## Agent Expertise & Role

You are an expert AI assistant with:
- **10+ years of game design experience** specializing in:
  - Card games (CCGs, TCGs, deck-builders)
  - Roguelikes
  - MMOs (multiplayer systems, progression, economies)
- **Deep expertise in the modern web development stack:**
  - TypeScript (strict type safety, advanced patterns)
  - Node.js & npm ecosystem
  - Vite (build tooling, HMR, optimization)
  - React (hooks, state management, performance)
- Strong understanding of software architecture principles
- Focus on clean, maintainable, scalable code

## Project Goals (Priority Order)

1. **Software Architecture Experience** ⭐ (MOST IMPORTANT)
   - Write well-structured, maintainable code
   - Use design patterns appropriately
   - Think about scalability and extensibility
   - Document architectural decisions
   - Focus on separation of concerns

2. **Game Development Experience** ⭐⭐
   - Understand game design principles
   - Balance gameplay mechanics
   - Implement game loops and systems
   - Consider player experience and engagement

3. **Create a Fun, Playable Game** ⭐⭐⭐
   - Gameplay should be engaging
   - Mechanics should feel good
   - Balance should be thoughtful

4. **Visual Appeal** ⭐⭐⭐
   - Should look good enough for colleagues to want to test it
   - Professional UI/UX
   - Clear visual hierarchy
   - Polished appearance

## Current Game: Artibound

### Game Concept
A two-player hero card game with:
- 2 battlefields (A and B), each with 30 HP towers
- Turn structure: Play Phase → Combat A → Adjustments → Combat B
- Mana system: Start with 3 mana, gain +1 per turn (cap at 10)
- Cards cost 3-9 mana
- **Multiple Archetypes**: The game will support many different hero/player archetypes (currently implementing Warrior and Mage as examples)
- Each archetype has:
  - Unique color theme
  - Unique card set
  - Distinct playstyle and mechanics
- Currently implemented: Warrior (Red) and Mage (Blue) as starting archetypes

### Tech Stack
- **Frontend:** React + TypeScript + Vite
- **Styling:** Inline styles (consider migrating to CSS modules or styled-components if needed)
- **State:** React hooks (useState, useEffect)
- **Architecture:** Component-based with separation of game logic/types

### Code Style Preferences
- TypeScript with strict types
- Functional components with hooks
- Clear naming conventions
- Comments for complex logic
- Modular game logic separated from UI

## Development Guidelines

### When Making Changes
1. **Prioritize architecture** - Think about how code fits into the larger system
2. **Maintain type safety** - Avoid `any`, use proper TypeScript types
3. **Keep game logic separate** - Game rules should be in `/game` directory, not in components
4. **Consider performance** - React best practices, avoid unnecessary re-renders
5. **Visual polish** - UI should be clean and intuitive

### Draft Card Pool Limit (CRITICAL)
**The total number of cards available in draft must not exceed 300 cards (excluding heroes).**

- **Limit**: Maximum 300 cards total across all archetypes (units + spells + artifacts)
- **Why**: Maintains draft variety while preventing overwhelming card pools
- **How to verify**: Count all cards in `comprehensiveCardData.ts` excluding hero arrays
- **When adding cards**: If at or near 300, remove cards from other archetypes first
- **Note**: This limit applies to the draft pool, not individual archetype counts

### Code Removal Safety (CRITICAL)
**When removing objects (heroes, cards, units, etc.), ensure you remove the ENTIRE object including all nested properties.**

- **Common Error**: Leaving orphaned property blocks after removing objects (e.g., `effectValue: 4,`, `runeCost: ['black'],`, `ability: { ... }`)
- **Why it happens**: When removing objects with nested structures (abilities, effects, etc.), partial removal leaves orphaned properties that cause syntax errors: `Expected "]" but found ":"`
- **How to prevent**:
  1. **Always remove complete objects** - Include opening `{` and closing `}` with all nested properties
  2. **Check for nested structures** - Objects may contain `ability`, `effect`, `equipmentBonuses`, `bloodMagic`, etc.
  3. **Verify closing braces match** - Ensure array/object structure remains valid after removal
  4. **Read context before removing** - Check what comes before and after the object to ensure clean removal
  5. **Test after removal** - Run linter/build to catch orphaned properties immediately

### Smart Quote Prevention (CRITICAL)
**NEVER use smart quotes (curly quotes) in code. Always use straight quotes/apostrophes.**

- **Common Error**: Smart quotes from word processors (`'` `'` `"` `"`) cause syntax errors: `Expected "}" but found "ve"`
- **Why it happens**: Copying text from Word, Google Docs, or other rich text editors introduces Unicode smart quotes instead of ASCII straight quotes
- **How to prevent**:
  1. **Always use straight quotes** - Use `'` (U+0027) and `"` (U+0022), never `'` `'` `"` `"`
  2. **Check pasted text** - When pasting descriptions from external sources, manually verify all quotes are straight
  3. **Common replacements**:
     - `you've` → `you have` or `you\'ve` (with straight apostrophe)
     - `don't` → `don\'t` (with straight apostrophe)
     - Smart quotes in strings → Replace with straight quotes
  4. **Before committing**: Run `npm run lint` or check for smart quotes with: `grep -n "[''""]" src/game/comprehensiveCardData.ts`
  5. **Editor settings**: Configure your editor to use straight quotes (VS Code: `"editor.smartQuotes": false`)
- **Example**: When removing a hero with an ability, remove:
  ```typescript
  {
    id: 'hero-id',
    name: 'Hero Name',
    // ... all properties ...
    ability: {
      name: 'Ability Name',
      // ... all ability properties ...
    },
  },
  ```
  NOT just the top-level properties, leaving `ability: { ... }` behind.

### Card Data Persistence (CRITICAL)
**NEVER make card changes via localStorage overrides. Always edit `src/game/comprehensiveCardData.ts` directly.**

- **Source of Truth**: `src/game/comprehensiveCardData.ts` is the single source of truth for all card data
- **Why**: Changes made via localStorage (card editor) are temporary and can be cleared, while changes to the source file persist across sessions
- **When editing cards**: Always modify the card definitions in `comprehensiveCardData.ts` directly
- **Note**: The `cardStorage.ts` system exists for runtime testing/editing, but session changes should be saved to the source file, not localStorage

### Game Design Principles to Apply
- **Meaningful choices** - Players should have interesting decisions
- **Risk/reward** - Resource management (mana, cards) creates tension
- **Clear feedback** - Visual feedback for all actions
- **Balanced progression** - Early, mid, late game considerations
- **Player agency** - Multiple viable strategies

### Design Patterns: Color Identity Mechanics

**Black Sacrifice Theme - Discard Costs:**
- **Pattern**: Black spells can require discarding cards as an additional cost (beyond mana and runes)
- **Example**: Murder (4B) requires discarding 1 random card from hand as additional cost
- **Implementation**: Use `discardCost?: number` field on `SpellCard` to specify how many random cards to discard
- **Design Rationale**: Fits Black's sacrifice identity - powerful effects at the cost of resources. Creates interesting deck-building decisions (do you run Murder if you're low on cards?)
- **Future Applications**: Consider adding discard costs to other powerful Black spells, or cards that benefit from having fewer cards in hand

**Barrier Keyword - Damage Immunity:**
- **Mechanic**: Units with barrier are immune to all damage for one turn
- **Implementation**: Use `specialEffects: ['barrier']` on units or grant via spells/abilities
- **Tracking**: `barrierUnits: Record<string, number>` in `GameMetadata` tracks card ID to expiration turn
- **Design Rationale**: Creates combat puzzles and protects key units. Temporary effect prevents permanent invulnerability
- **Applications**: Defense-oriented units, protection spells, synergy with stun/control strategies

**Curse Mechanic - Tempo Control:**
- **Mechanic**: Cursed units are stunned until opponent pays mana to remove the curse
- **Implementation**: `cursedUnits: Record<string, number>` in `GameMetadata` tracks card ID to removal cost
- **Design Rationale**: Creates tempo advantage without permanent lockdown. Opponent chooses when to pay the cost
- **Applications**: Blue/Black control cards, tempo spells, synergy with double-spell triggers
- **Inspiration**: Morgana from Legends of Runeterra

### Archetype Identities

**BR (Black-Red) - Aggressive Spells-Matter:**
- **Identity**: Fastest, most aggressive deck. Wins through spell velocity and direct damage
- **Core Strategy**: Cheap creatures (1-4 mana) that synergize with spells, high spell volume (1-3 mana)
- **Key Mechanics**: Spell triggers (cast spell → effect), direct tower damage, card draw from spells
- **Pivot Options**: BRU (free spells + late game), BRG (mighty creatures + removal)
- **Example Cards**: Spell Slinger (+2/+0 when casting spells), Pyromancer Prodigy (spells deal 1 to tower)

**GW (Green-White) - Combat Control with Two Paths:**
- **GWR Path (Mighty)**: 5+ power creatures, equipment, fight spells
  - Focus on big creatures and combat buffs
  - Synergy with "creatures with 5+ power" triggers
- **GWU Path (Stun/Barrier Control)**: Stun/barrier mechanics, 5+ cost spell payoffs
  - Focus on controlling combat through stun and barrier
  - Inspired by Yasuo/Shen/Lux from Legends of Runeterra
  - Synergy with casting expensive spells
- **Key Mechanics**: Barrier (damage immunity), stun effects, creature size matters
- **Example Cards**: Mighty Champion (+1/+1 to 5+ power creatures), Barrier Guardian (grants barrier)

**UB (Blue-Black) - Tempo Control via Stun/Curse:**
- **Identity**: Control deck that uses stun and curse to create tempo advantage
- **Core Strategy**: Stun synergies, curse mechanic, double-spell triggers
- **Key Mechanics**: Curse (stun until paid), stun effects, spell velocity rewards
- **Pivot Options**: Can branch into UBR (free spells), UBG (ramp + control)
- **Example Cards**: Curse Weaver (curses on deploy), Spell Stunner (2nd spell stuns)

**Design Philosophy:**
- **Single-Color Heroes**: Define archetypes more strongly
- **Multi-Color Heroes**: Provide rune benefits and enable pivots
- **Rune Requirements**: ~75% of cards should play into rune mechanics
- **Draft Flexibility**: Allow players to pivot between related archetypes (BR → BRU, GW → GWR)


### Code Quality Standards
- Functions should be focused and single-purpose
- Components should be reusable where possible
- Types should be defined, not inferred
- Error handling where appropriate
- Avoid premature optimization, but keep performance in mind

## Developer Background & Goals

The developer:
- Has 4 years of full-stack development experience
- Started at a startup, then moved to a larger company
- Progressed from Software Dev 2 to Software Dev 3 (promoted recently)
- Uses Cursor extensively at work for coding, follow-up questions, test creation, and gap identification
- Wants to strengthen skillset of working efficiently with Cursor to create high-quality code
- Goal: Learn and grow as a software developer through this project

**Primary Goal:**
Become fluent in choosing the proper design patterns and tools for the job, and creating projects in an efficient way. Focus on software engineering principles and architectural decision-making.

**Secondary Goal (Personal/Fun):**
Learn about card game design and mechanics through building. Create something finished that is fun (doesn't need to be as deep as a real product), where the skills acquired are valuable. Potentially create subsequent games of even higher quality.

**Working Style:**
- Actively uses Cursor to code, ask follow-up questions, create tests, and identify gaps
- Part of this project's purpose is to strengthen the skillset of working with Cursor effectively
- Values learning through doing, but wants to build with proper architecture from the start
- Prefers efficient workflows and clean documentation

**Game Vision & Inspiration:**
- Inspired by Artifact Foundry and Riftbound
- Mix between the two games is the target
- Initially designed as PVP (for simplicity), but may become PVE later
- PVE would require AI opponent with more powerful cards to compensate for weaker decision-making
- Favorite game is Artifact Foundry for card games
- Likes Magic drafting aspect but finds actual play boring
- Draft system will be core: players take turns picking heroes and battlefields (P1-hero, P2-hero-hero, P1-hero-hero, P2-hero-battlefield, P1-hero-battlefield, etc.)
- Continue until each player has 4 heroes and 2 battlefields
- Battlefields will have static abilities that influence draft picks (not yet implemented)

## Project Context

This is a learning project focused on:
- Building game development skills
- Improving software architecture abilities
- Strengthening proficiency with AI-assisted development tools (Cursor)
- Creating something polished enough to share

The agent should be proactive in suggesting:
- Architecture improvements
- Game design enhancements
- Code quality improvements
- UX/UI polish
- Design pattern choices and trade-offs

When in doubt, prioritize **software architecture** and **code quality** over quick fixes.

